**[Course](../README.md)**
&emsp;[Study materials](#study-materials)
&emsp;[Homework assignment](./homework/README.md)

# Pesistence

**Use container volumes and mounts**

Hello and welcome to Docker course and its next learning session devoted to persistence.

Today we are going to see how to persist and safe data using docker mounts and volumes, how to share the same data with multiple containers. We will make data available to container in a read only mode. We will try ephemeral volumes, and see how to quickly remove unused volumes.

## Why do we need pesistency?

By the definition container are small, portable and disposable.
We tend to keep them small and having no redundant data.

Once a running image is stopped and removed its data and created files get wiped out by Docker system.
But usually we need some data be persistent, meaning its must stay and be accessible after the application that created it has been closed.

There are several reasons why we might want to use Docker persistency.

- Container can generate data that we need to use later.

- Container might need to start from a previous state. This is useful for things like database files.

- We might need to share the same data between multiple containers. This can be useful for things like storing shared configuration files or data used by multiple containers.

Let's see these use cases in practice.

## Bind mounts

We will start from an example that generates a file that must exist after the container is gone.

We need a dockerfile that defines an image for our container.

```sh
cat host-bind/Dockerfile
```
```Dockerfile
FROM busybox

WORKDIR /workspace

ENTRYPOINT [ "sh", "-c", "echo $(date) hello from $(hostname) > result" ]
```

Using [WORKDIR] instruction, we create directory named `workspace` and set it as a working directory.

The [ENTRYPOINT] executes a small shell script that writes a message containing current date and container's hostname into file named `result`. The file will be created in working directory which is `workspace`.

Let's build an image.

```sh
docker build host-bind --tag sandbox
```

We need a new directory in our current working directory.

```sh
mkdir storage
```

We can bind a directory on the host filesystem to a directory in a container's filesystem by using `--volume` option of the [docker run] command.

```sh
docker run --rm --volume ./storage:/workspace sandbox
```

For the volume option we specified a string that contains two paths separated by column. The first path refers to host filesystem while the second one to container filesystem. It is required to use `./` here to refer current directory.

We can list the `storage` directory contents to ensure we got the resulting file.
```sh
ls storage
```

Indeed we got the file and it's not empty. Let's check the file content.

```sh
cat storage/result
```

As we can see the container is gone but the result is present at the directory we bound to the container.

We can use this approach in case when we need to share data between two or more containers.

Let's clean up the `storage` directory

```sh
rm storage/*
```

We need two containers sharing the same directory on host filesystem.
Let's run the first container in interactive mode.

```sh
docker run --rm --interactive --tty --volume ./storage:/data:ro busybox
```

This time we added `:ro` to `--volume` option, meaning we need a read only access. We need this container to only read data that another container will produce.

We can check that the contianer has `data` directory in its file system.

```sh
ls
```

We can ensure that the `data` directory is read only by trying to create an empty file there.

```sh
touch data/dummy
```
>```
>touch: data/dummy: Read-only file system
>```

Let's run second container bound to the same host directory. We have to use another terminal since the current one is occupied by interactive session.

```sh
docker run --rm --volume ./storage:/workspace sandbox
```

Notice that for second container we use `workspace` as a destination for the bind. If we chose another directory there will be no error because Docker will create the specified destination directory in the container filesystem. But because the script we use in the container doesn't aware of this directory we won't get the result into our host filesystem.

The container started, did his job and has been terminated and disposed.

Let's check if the first container can see the resulting file that was generated by the second container.

```sh
ls data
cat data/result
```

Since the files generated by a container are in directory that bound to host's filesystem, each time when we run a new container bound to the same directory it will get these files.

If we use a host's directory and run a new container from the same image, each time binding a directory or a file in container's filesystem to the same host directory or file, the new container will start with data stored from previous run. This way we can achive data persistency.

But this not a best option. Let's look how to use volumes instead.

## Volumes

In the context of Docker, a volume is a persistent storage location that exists outside of the container. Volumes are useful for storing data that needs to persist even if the container is stopped or removed. Even if a container is destroyed the data it has generated is intact.

For demostration we need a following simple dockerfile.

```sh
cat volume-bind/state/Dockerfile
```
```Dockerfile
FROM busybox

WORKDIR /logs

ENTRYPOINT [ "sh", "-c", "date >> time-log && cat time-log" ]
```

In the dockerfile we define `logs` as a working directory. According to the entrypoint, each time we will run a container it will add a new record into `time-logs` file in the working directory, and will print out content of the file.

Let's build an image.

```sh
docker build volume-bind/state --tag time-logger
```

Let's run a container.

```sh
docker run --rm time-logger
```

It printed out one record.

We can run a container multiple times and everytime we will see only one record. It happens because Docker allocates fresh filesystem for each new container. Let's a use volume to make the `logs` persistent.

```sh
docker run --rm --volume logs:/logs time-logger
```

Each time we run a new container by means of this command we see more records.

In Docker, volume is another kind of resources. We can list all the volumes present in Docker system by using [docker volume ls] command.

```sh
docker volume ls
```

We can also create, inspect, remove and prune volumes.

Let's inspect the `logs` volume.

```sh
docker volume inspect logs
```

The `Mountpoint` we see here points to a directory inside the docker system. When running Docker on Windows and MacOS the path does not correspond to the hosts system's path. On Linux it does, because Docker runs natively on Linux. So, on Windows or MacOS we can't simple go the path and see data stored there.

Let's see how we can share data between containers using volumens mechanism.

We could run each container specifying the same volume name in `--volume` option of the [docker run] command. But let's use a different technique.

We'll start a new interactive container from busybox image, and we will give it a name.

```sh
docker run --rm --interactive --tty --volume /logs --name sandbox busybox
```

For the `--volume` option we don't use a column separated string containing volume name and destination path. We use only the destination path.

From `Lazydocker` we see that a new volume has been created and it has a long hash as its name.

Now we can start the container that will generate a time log records.

```sh
docker run --rm --volumes-from sandbox time-logger
```

This time in the [docker run] command we use `--volumes-from` option and specify name of the first container. Docker will read information about volumes from the specified container and will bind them all to a new container using destination paths from referred container.

Let's run a container several times.

Then let's see what is in the `/logs` directory of the first container.

```sh
ls logs
```

It contains `time-log` file. Let's see it content.

```sh
cat logs/time-log
```

It has all the time records the second container has created.

We can exit the first container.

As you see the volume has dissapeared. It happend because Docker created it automatically when we ran the first container. And Docker set the container as owner of the volume. Since we created a disposable conainer by using `--rm` option, once the container has been discarded its volume has been discarded as well.

## Dockerfile

Docker has special Dockerfile instruction that supports volumes. Let's look how we can use it.

```sh
cat simple/Dockerfile
```
```Dockerfile
FROM busybox

VOLUME /data
```

This simple Docker file has [VOLUME] istruction that declares `/data` directory as a volume.

```sh
docker build simple --tag sandbox
```

Let's run a container.

```sh
docker run --rm --interactive --tty sandbox
```

We see there is a volume appeared in the volumes list. So the [VOLUME] instruction actually command the Docker system to create a volume when we run a container.

```sh
docker volume ls
```

We can exit from the running container.

```sh
exit
```

When we exit the interactive session, the container got removed and the volume as well.
This happend because we ran the container with `--rm` flag, meaning we ran it as disposable.

Let's run non-disposable container and add some data.

```sh
docker run --interactive --tty --name sandbox sandbox
```

This time we named our container to be able to refer it later.

Create a file in `/data` directory.

```sh
echo hello from $(hostname) > /data/greeting
```

Make sure the file exists.

```sh
ls /data
```

And make sure the file is not empty.

```sh
cat /data/greeting
```

We can exit from the container now.

```sh
exit
```

By using `Lazydocker` or [docker volume ls] command we can ensure that the volume is still in place.

```sh
docker volume ls
```

Frankly speaking, we don't need a volume to get data from stopped container. We can use [docker cp] command to copy file from the stopped container filesystem.

```sh
docker cp sandbox:/data/greeting .
```

```sh
cat greeting
```

Let's remove the stopped container. We can use [docker container prune] command to remove all stoped containers.

```sh
docker container prune --force
```

Since the container was removed we can't access its filesystem anymore. But the part of its filesystem that was bound to a volume is still exists.

We can get access to it either through the volume mountpoint referring to docker host storage or we can create another container and attach the volume to its filesystem.

```sh
docker run --rm --interactive --tty --volume [ID]:/workspace busybox
```

```sh
cat /workspace/greeting
```

So what is the purpose of [VOLUME] instruction in a Dockerfile?

The instruction creates a manageable mount point inside a container and logically separates data from the container itself.

And we can use [docker image inspect] command to view all volume mount points created in an image.

Let's see an example of dockerfile that defines two volumes.

```sh
cat multiple-volumes/Dockerfile
```
```Dockerfile
FROM busybox

VOLUME /var/data /var/logs
```

Here we declare two volumes or mount points.

Let's build an image.

```sh
docker build multiple-volumes --tag sandbox
```

We can use [docker image inspect] command to see the volumes.

```sh
docker image inspect sandbox --format '{{ json .Config.Volumes }}'
```

If any build steps change the data within the volume after it has been declared, those changes will be discarded. Let's see it on example.

```sh
cat modify-volume/Dockerfile
```
```Dockerfile
FROM busybox

VOLUME /data

RUN echo hello > /data/hello
```

In this dockerfile we declare volume for `/data` directory. Then using [RUN] instruction we create `hello` file in this directory.

Let's build an image and run a container.

```sh
docker build modify-volume --tag sandbox
docker run --rm --interactive --tty sandbox
```

We see no files in `/data` directory

```sh```

### Pre-populated

Though if we modify a directory content before we declare a volume for it, we would create a pre-populated volume.

Let's see an example Dockerfile that does this.

```sh
cat pre-populated/Dockerfile
```
```Dockerfile
FROM busybox

RUN mkdir /data

RUN uname -a > /data/name
RUN hostname > /data/hostname

VOLUME [ "/data" ]
```

Firstly, we have to create directory.
Then we can create files in the directory.
Then we declare a volume.

Let's build an image.

```sh
docker build pre-populated --tag sandbox
```

Let's run a container and map volume named `hub` to the mount point for `/data` directory.

```sh
docker run --rm --volume hub:/data sandbox
```

It is not required to create a volume upfront. The [docker run] command will create it for us if it doesn't exist.

In `Lazydocker` we see the `hub` volume in `Volumes` section.

This time we didn't run a container in interactive mode so it starts and exists immediately.

Let's try to use the volume by running a container from another image in interactive mode.

```sh
docker run --rm --interactive --tty --volume hub:/workspace busybox
```

We can use the following commands to ensure the pre-populated files exist.

```sh
ls
ls /workspace
cat /workspace/name
cat /workspace/hostname
```

### Bound-mount to mount point

Let's try to bind our host current directory to the mount point instead of using a volume.

```sh
docker run --rm --interactive --tty --volume .:/data sandbox
```

Let's list the `/data` directory content.

```sh
ls /data
```

If we bind-mount a directory into a non-empty directory on the container, the directory's existing contents are obscured by the bind mount. This can be beneficial, such as when we want to test a new version of our application without building a new image.

## Tmpfs mounts

There is one more kind of volumes Docker provides. It is ephemeral or disposable volume.

This is useful to temporarily store sensitive files that we don't want to persist in either the host or the container writable layer.

Let's run a container binding a volume but using a bit different syntax.

```sh
docker run --rm --interactive --tty --mount type=volume,dst=/secret --name blackbox busybox
```

Instead of `--volume` option we use `--mount` which is a recommended way to declare container mounts. The mount option is more flexible because it uses a key-value pairs to define a mount point properties.

Let's ispect the container mounts via [docker inspect] command.

```sh
docker inspect blackbox --format '{{ json .Mounts }}'
```
```json
[
  {
    "Type": "volume",
    "Name": "d9fcc471c590851a5991d1d5f1353c5732be8876baedc14791128a212f67591d",
    "Source": "/var/lib/docker/volumes/d9fcc471c590851a5991d1d5f1353c5732be8876baedc14791128a212f67591d/_data",
    "Destination": "/secret",
    "Driver": "local",
    "Mode": "z",
    "RW": true,
    "Propagation": ""
  }
]
```

Now let's use a disposable volume for container's `/secret` directory.

```sh
docker run --rm --interactive --tty --mount type=tmpfs,dst=/secret --name blackbox busybox
```

Let's inspect the mount properties.

```sh
docker inspect blackbox --format '{{ json .Mounts }}'
```
```json
[
  {
    "Type": "tmpfs",
    "Source": "",
    "Destination": "/secret",
    "Mode": "",
    "RW": true,
    "Propagation": ""
  }
]
```

We see no source defined for the mount, meaning there is no persistent storage for the mount point.

Unlike volumes and bind mounts, we can't share `tmpfs` mounts between containers.

This functionality is only available if we're running Docker on Linux or MacOS.

## Clean up

```sh
docker volume rm
```

```sh
docker volume prune
```

```sh
docker system prune --volumes
```

## Epilogue

![Volumes on the Docker host](https://docs.docker.com/storage/images/types-of-mounts-volume.webp)

On todays session we saw how Docker volumes and mounts can be used to make contaier's data persistent. We saw examples of using bind-mounts and volumes to keep container's state and to share data between containers.

## Study materials

[Docker storage](https://capgemini.udemy.com/course/learn-docker/learn/lecture/15829082#overview)

[Managing docker volumes](https://capgemini.udemy.com/course/docker-tutorial/learn/lecture/16369728#overview)

## References

[Docker Mount Volume – How To Mount a Local Directory](https://www.freecodecamp.org/news/docker-mount-volume-guide-how-to-mount-a-local-directory/)

[What is the purpose of VOLUME in Dockerfile?](https://www.tutorialspoint.com/what-is-the-purpose-of-volume-in-dockerfile)

[docker container prune]: https://docs.docker.com/engine/reference/commandline/container_prune/
[docker cp]: https://docs.docker.com/engine/reference/commandline/cp/
[docker image inspect]: https://docs.docker.com/engine/reference/commandline/image_inspect/
[docker run]: https://docs.docker.com/engine/reference/commandline/run/
[docker volume ls]: https://docs.docker.com/engine/reference/commandline/volume_ls/
[docker inspect]: https://docs.docker.com/engine/reference/commandline/inspect/
[ENTRYPOINT]: https://docs.docker.com/engine/reference/builder/#entrypoint
[RUN]: https://docs.docker.com/engine/reference/builder/#run
[VOLUME]: https://docs.docker.com/engine/reference/builder/#volume
[WORKDIR]: https://docs.docker.com/engine/reference/builder/#workdir

---
**[Top](#)**
&emsp;[Course](/README.md)
<div align="right">[:loudspeaker: Report issue](https://gitlab.lohika.com/study/docker/way/-/issues/new)</div>
